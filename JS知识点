# JS

### JS的特性
+ 解释性语言：解释型语言是对代码进行一句一句的直接运行，在程序运行期间，使用解释器动态将代码解释为机器码，再运行。
+ 单线程：JS 是单线程的，但是却能执行异步任务，这主要是因为 JS 中存在事件循环（Event Loop）和任务队列（Task Queue）

### Promise
所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）
Promise对象有以下两个特点。
（1）对象的状态不受外界影响。
（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。
Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。
resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。

### JS加载时间线
在js加载开始的时候，浏览器会记录js执行的这段过程。
1、创建Document对象，开始解析web页面，解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。
这个阶段document.readyState = "loading"。
2、遇到link外部css，创建线程加载，并继续解析文档。
3、遇到script外部js，并且没有设置async，defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档
4、遇到script外部js，并且设置有async，defer 浏览器创建线程加载，并继续解析文档，对于async属性的脚本，脚本加载完成后立即执行
（异步禁止使用docuemnt.write（）会消除文档流）
5、遇到img标签等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档
6、当文档解析完成，document.readyState = "interactive"；
7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。
8、当文档解析完成之后，document对象触发DOMContentLoaded事件
这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段
9、当所有saync的脚本加载完成并执行后，img等加载完成后，
document.readyState = "complete"
window对象触发load事件
10、从此，页面以异步响应方式处理用户输入，网络事件等。


### 事件触发三阶段
事件触发有三个阶段
* window 往事件触发处传播，遇到注册的捕获事件会触发
* 传播到事件触发处时触发注册的事件
* 从事件触发处往 window 传播，遇到注册的冒泡事件会触发
事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。





### call 与 apply
+ call和apply的作用都是改变this作用域，都是在特定作用域中调用函数。当一个对象没有某个方法，而其他对象有，我们就可以使用call或apply实现某个方法的复用。
+ call和apply使用方法基本相同，唯一不同之处就是它们的参数规则：call方法接受一个参数列表，而apply方法接受一个包含多个参数的数组。



### new一个对象的过程中发生了什么
1. 创建空对象；
	var obj = {};
2. 设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；
	obj.__proto__ = ClassA.prototype;
3. 使用新对象调用函数，函数中的this被指向新实例对象：
	ClassA.call(obj);//{}.构造函数();
4. 将初始化完毕的新对象地址，保存到等号左边的变量中





### 深拷贝、浅拷贝
浅拷贝和深拷贝都只针对于引用数据类型
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；
但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象
区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制



### 堆和栈
栈(stack)：栈会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。
堆(heap)：动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。



### JS运行三步骤
1. 语法分析
2. 预编译
3. 解释执行

### 预编译
预编译发生在代码执行的前一刻
步骤：
1.创建GO/AO对象 
AO Activation Object 执行期上下文 函数预编译，在函数执行前一刻
GO Global Object 在整个代码运行前一刻
2.找形参和变量声明，将变量和形参名作为AO属性名，值为undefined
3.将实参值和形参统一
4.在函数体里面找函数声明，值赋予函数体 （注：没有函数表达式 function () {} ）


### js中函数执行
1. 确定“this”的值 (确切的来说，this在JS里面不是一个变量名而是一个关键字)
2. 创建一个新的作用域
3. 处理形参/实参（没有定义过才声明，无论如何都重新赋值，没有对应实参则赋值为"undefined"）
4. 处理函数定义（没有定义过才声明，无论如何都重新赋值）
5. 处理 "arguments"（没有定义过才声明和赋值）
6. 处理变量声明（没有定义过才声明，不赋值）


